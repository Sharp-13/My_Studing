### Задача 1: таблиця ASCII і конвертація рядків за її допомогою.

# Цифри, літери латинського алфавіту і деякі спеціальні символи ($, @, \n, \t тощо) традиційно представляються в пам'яті комп'ютера
# згідно [таблиці ASCII](https://www.ascii-codes.com/cp855.html). В стандартній таблиці ASCII представлено 128 символі (2**8).
# В сучасному світі таблиця ASCII замінена на Unicode для репрезентації більш широкого спектру символів
# (кирилічний алфавіт, грецький алфавіт, різні спецсимволи, емоджи тощо).
# Але всі коди в ASCII входять у Unicode незмінно (тобто, Unicode є надмножиною для ASCII). Більше про різницю між ними [тут](https://www.javatpoint.com/ascii-vs-unicode).
#
# В Python ASCII/Unicode-код символа може бути отриманий за допомогою функції ord().
# І, натомість, в Python ми можемо отримати символ за його ASCII/Unicode номером за допомогою вбудованої функції chr().
#
# Знаючи це, створіть три окремі рядки:
# 1. Вхідний рядок, переведений у Upper Case
# 2. Вхідний рядок, переведений у Lower Case
# 3. Вхідний рядок, переведений у один рядок (без символів кінця рядку)
#
# і виведіть результат.
# Робити це треба виключно використовуючи таблицю ASCII. Всі символи, що відрізняються від латинського алфавіту, мають бути збережені без змін.

input_str = """Hello! My name is Ілля!
My email is illya.khoroshykh@gmail.com. I have 10$ in my pocket. 
& wut 'bout u?'"""

delta = ord('a') - ord('A')
print(ord('a'), ord('z'), ord('A'), ord('Z'))
#print(delta)
new_lower_string = ''
for item in input_str:
    if (ord(item) >=65 and ord(item) <= 90):
        new_lower_string = new_lower_string + chr(ord(item)+delta)
    else:
        new_lower_string = new_lower_string + item

new_upper_string = ''
for item in input_str:
    if (ord(item) >=97 and ord(item) <= 122):
        new_upper_string = new_upper_string + chr(ord(item)-delta)
    else:
        new_upper_string = new_upper_string + item

print(new_lower_string)
print(new_upper_string)

new_result_string = ''
for item in input_str:
    if ord(item) != 10:
        new_result_string = new_result_string + item

print(new_result_string)

# Задача 2: Зробити програму, що приймає дві команди:
# fac і fib.
# Якщо прийшла команда fac, програма має спитати в користувача число і порахувати його факторіал
# Якщо прийшла команда fib, програма має спитати в користувача число і порахувати відповідне число Фібоначчі
# Програма приймає на вхід тільки цілі числа більше або дорівнюючи нулю. Для цілей задачі можемо не розглядати випадки, коли введено невалідне число чи невалідна команда.
# Бажано створити імплементацію як циклом for, так і циклом while.

# Задача 2: валідатор пароля.
#
# Написати консольний застосунок, що приймає на вхід два рядки:
#
#     Пароль
#     Пароль повторно
#
# І перевіряє наступне:
#
#     Рівність рядків між собою
#     Довжину пароля (не менше 8 символів)
#     Наявність як великих, так і малих літер
#     Наявність цифр
#     Наявність спецсимволів (не алфавітних або числових)
#
# У випадку не проходження однієї з перевірок програма має заново запитати пароль у користувача.
# Програма має завершити роботу одразу після введення валідного пароля двічі.

# Задача 3: простий консольний калькулятор
#
# Написати консольний застосунок, що приймає на вхід дві команди:
#
#     calculate
#     end
#
# У випадку команди calculate, застосунок має проінструктувати користувача, що йому треба ввести послідовно два числа та одну з дозволених бінарних арифметичних операцій.
#
# У випадку введення невалідних чисел чи операторів, треба вивести повідомлення про помилку і попросити користувача ввести операнди та оператор заново.
#
# Після вводу операндів і оператору, треба вивести результат. Після виведення результату програма має запитувати наступну команду від користувача. У випадку команди end програма має завершувати роботу.
#
# Програма приймає на вхід виключно цілі числа.
#
# P.S. До речі, подібний підхід до запису арифметичних виразів (оператор після операндів) називається зворотна польська нотація.